import express from "express";
import { ApolloServer } from "@apollo/server";
import { expressMiddleware } from "@apollo/server/express4";
import bodyParser from "body-parser";
import cors from "cors";
import fetch from "node-fetch";

const GO_BACKEND_URL = "http://localhost:8080/query";

const typeDefs = `#graphql
  type User {
    id: ID!
    email: String!
    name: String!
    phone: String
    address: String
    role: String!
    createdAt: String!
  }

  input RegisterInput {
    email: String!
    password: String!
    name: String!
    phone: String
    address: String
  }

  input LoginInput {
    email: String!
    password: String!
  }

  type AuthPayload {
    token: String!
    user: User!
  }

  type Query {
    me: User!
    getUser(id: ID!): User
    getCart(cartId: ID, forUser: Boolean): Cart!
    products(isActive: Boolean): [Product!]!
    product(id: ID!): Product
  }

  type Product {
    id: ID!
    name: String!
    basePrice: Float!
    description: String!
    designImageURL: String!
    isActive: Boolean
    material: String
    neckline: String
    sleeveType: String
    fit: String
    brand: String
    category: String
    careInstructions: [String!]
    weight: Float
    featured: Boolean
    variants: [ProductVariant!]
    createdAt: String
  }

  type ProductVariant {
    id: ID!
    size: String
    color: String
    priceModifier: Float
    sku: String
    price: Float
    inventory: Inventory
  }

  type Inventory {
    id: ID!
    stockQuantity: Int!
    reservedQuantity: Int!
    availableQuantity: Int!
  }

  type CartItem {
    id: ID!
    productId: ID!
    variantId: ID
    quantity: Int!
    unitPrice: Float!
    createdAt: String!
    updatedAt: String!
  }

  type Cart {
    id: ID!
    userId: ID
    items: [CartItem!]!
    totalAmount: Float!
    createdAt: String!
    updatedAt: String!
  }

  input AddToCartInput {
    cartId: ID
    productId: ID!
    variantId: ID  # GraphQL uses camelCase, backend Go code accesses as VariantID
    quantity: Int!
  }

  type AddToCartPayload {
    cart: Cart!
  }

  input RemoveCartItemInput {
    cartId: ID!
    cartItemId: ID!
  }

  type RemoveCartItemPayload {
    cart: Cart!
  }

  input ClearCartInput {
    cartId: ID!
  }

  type ClearCartPayload {
    cart: Cart!
  }

  input AttachCartToUserInput {
    cartId: ID!
    userId: ID!
  }

  type AttachCartToUserPayload {
    cart: Cart!
  }

  type CreateOrderInput {
    shippingAddress: String!
  }

  type Order {
    id: ID!
    shippingAddress: String!
    createdAt: String!
  }

  type CreateOrderPayload {
    id: ID!
  }

  type Mutation {
    register(input: RegisterInput!): AuthPayload!
    login(input: LoginInput!): AuthPayload!
    updateProfile(name: String, phone: String, address: String): User!
    addToCart(input: AddToCartInput!): AddToCartPayload!
    removeCartItem(input: RemoveCartItemInput!): RemoveCartItemPayload!
    clearCart(input: ClearCartInput!): ClearCartPayload!
    attachCartToUser(input: AttachCartToUserInput!): AttachCartToUserPayload!
    createOrder(input: CreateOrderInput!): CreateOrderPayload!
  }
`;

async function forward(query, variables, token) {
  const cleanToken = token?.startsWith("Bearer ")
    ? token
    : token
    ? `Bearer ${token}`
    : "";

  try {
    const requestBody = { query, variables };
    console.log("\nğŸ”„ FORWARDING TO BACKEND:");
    console.log("ğŸ“ URL:", GO_BACKEND_URL);
    console.log("ğŸ”‘ Has Token:", !!cleanToken);
    console.log("ğŸ“ Query:", query?.substring(0, 300) + (query?.length > 300 ? "..." : ""));
    console.log("ğŸ“¦ Variables:", JSON.stringify(variables, null, 2));
    console.log("ğŸ” Token:", cleanToken ? `${cleanToken.substring(0, 50)}...` : "none");

    const response = await fetch(GO_BACKEND_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...(cleanToken ? { Authorization: cleanToken } : {})
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error("Backend request failed:", {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      throw new Error(`Backend request failed: ${response.status} ${response.statusText}`);
    }

    const result = await response.json();
    
    console.log("âœ… BACKEND RESPONSE:");
    console.log("ğŸ“¦ Data:", result.data ? "Present" : "Missing");
    if (result.errors) {
      console.error("âŒ Backend GraphQL errors:");
      result.errors.forEach((err, idx) => {
        console.error(`  Error ${idx + 1}:`, {
          message: err.message,
          path: err.path,
          extensions: err.extensions
        });
      });
      
      // Check for authentication errors
      const authError = result.errors.find(e => 
        e.message?.toLowerCase().includes("unauthorized") ||
        e.message?.toLowerCase().includes("not logged in") ||
        e.extensions?.code === "UNAUTHENTICATED"
      );
      
      if (authError) {
        console.error("ğŸ” AUTHENTICATION ERROR: User is not authenticated!");
        console.error("   Make sure you are signed in via Clerk");
      }
    } else {
      console.log("âœ… No errors from backend");
    }
    console.log(""); // Empty line for readability
    
    return result;
  } catch (error) {
    console.error("Error forwarding request to backend:", {
      error: error.message,
      stack: error.stack,
      url: GO_BACKEND_URL
    });
    throw error;
  }
}

const resolvers = {
  Query: {
    me: async (_, vars, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in me query:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.me;
    },
    getUser: async (_, vars, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in getUser query:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.getUser;
    },
    getCart: async (_, vars, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in getCart query:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.getCart;
    },
    products: async (_, vars, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in products query:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.products || [];
    },
    product: async (_, vars, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in product query:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.product;
    }
  },

  Mutation: {
    register: async (_, vars, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in register mutation:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.register;
    },

    login: async (_, vars, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in login mutation:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.login;
    },

    updateProfile: async (_, vars, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in updateProfile mutation:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.updateProfile;
    },

    addToCart: async (_, { input }, ctx) => {
      console.log("\nğŸ›’ addToCart mutation received:");
      console.log("  Input:", JSON.stringify(input, null, 2));
      console.log("  Auth token:", ctx.token ? `${ctx.token.substring(0, 30)}...` : "âŒ NONE");
      
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      
      if (r.errors) {
        console.error("âŒ GraphQL errors in addToCart mutation:");
        r.errors.forEach((err, idx) => {
          console.error(`  Error ${idx + 1}:`, err.message);
        });
        
        // Check if it's an auth error
        const authError = r.errors.find(e => 
          e.message?.toLowerCase().includes("unauthorized") ||
          e.message?.toLowerCase().includes("not logged in")
        );
        
        if (authError) {
          throw new Error("Authentication required: Please sign in to add items to cart");
        }
        
        const errorMessage = r.errors[0]?.message || "Internal system error";
        throw new Error(errorMessage);
      }
      
      if (!r.data?.addToCart) {
        console.error("âŒ No data returned from addToCart mutation");
        throw new Error("Backend returned no data");
      }
      
      console.log("âœ… addToCart successful");
      return r.data.addToCart;
    },

    removeCartItem: async (_, { input }, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in removeCartItem mutation:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.removeCartItem;
    },

    clearCart: async (_, { input }, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in clearCart mutation:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.clearCart;
    },

    attachCartToUser: async (_, { input }, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in attachCartToUser mutation:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.attachCartToUser;
    },

    createOrder: async (_, { input }, ctx) => {
      const r = await forward(ctx.query, ctx.variables, ctx.token);
      if (r.errors) {
        console.error("GraphQL errors in createOrder mutation:", r.errors);
        throw new Error(r.errors[0]?.message || "Internal system error");
      }
      return r.data?.createOrder;
    }
  }
};

async function start() {
  console.log("ğŸš€ Starting GraphQL proxy server...");
  console.log("ğŸ“¡ Backend URL (Render):", GO_BACKEND_URL);
  console.log("ğŸ“ Proxy will listen on: http://localhost:8081/query");
  
  const app = express();

  // Add request logging middleware BEFORE Apollo
  app.use("/query", (req, res, next) => {
    console.log("\n=== INCOMING REQUEST ===");
    console.log("Method:", req.method);
    console.log("URL:", req.url);
    console.log("Headers:", {
      authorization: req.headers.authorization ? `${req.headers.authorization.substring(0, 30)}...` : "none",
      "content-type": req.headers["content-type"]
    });
    console.log("Body:", JSON.stringify(req.body, null, 2));
    console.log("=======================\n");
    next();
  });

  const server = new ApolloServer({ 
    typeDefs, 
    resolvers,
    formatError: (err) => {
      console.error("âŒ Apollo Server Error:", {
        message: err.message,
        path: err.path,
        extensions: err.extensions,
        originalError: err.originalError
      });
      return {
        message: err.message || "Internal system error",
        extensions: {
          code: err.extensions?.code || "INTERNAL_SERVER_ERROR",
          originalError: process.env.NODE_ENV === "development" ? err : undefined
        }
      };
    }
  });
  
  await server.start();
  console.log("âœ… Apollo Server started");

  // Enhanced CORS configuration to handle multiple environments
  const corsOptions = {
    origin: [
      "http://localhost:3000",
      "http://127.0.0.1:3000",
      "http://localhost:3001",
      "http://127.0.0.1:3001",
      "http://localhost:8081",
    ],
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
    credentials: true,
    optionsSuccessStatus: 200,
  };

  app.use(
    "/query",
    cors(corsOptions),
    bodyParser.json({ limit: "5mb" }),
    expressMiddleware(server, {
      context: async ({ req }) => {
        // Extract Authorization header - this comes from Clerk via Apollo Client
        // Format: "Bearer <clerk-jwt-token>"
        const authHeader = req.headers.authorization || "";
        console.log("ğŸ” Auth header received:", authHeader ? `${authHeader.substring(0, 30)}...` : "âŒ NONE");
        console.log("ğŸ“ Query:", req.body?.query?.substring(0, 100) + "...");
        console.log("ğŸ“¦ Variables:", JSON.stringify(req.body?.variables));
        
        return {
          token: authHeader, // Forward the full "Bearer <token>" to backend
          query: req.body.query,
          variables: req.body.variables
        };
      },
    })
  );

  // Health check endpoint
  app.get("/health", (req, res) => {
    res.json({ 
      status: "ok", 
      backend: GO_BACKEND_URL,
      timestamp: new Date().toISOString()
    });
  });

  const PORT = process.env.PORT || 8081;
  app.listen(PORT, () => {
    console.log("\n" + "=".repeat(50));
    console.log(`âœ… GraphQL Proxy Server is RUNNING`);
    console.log(`ğŸ“ Listening on: http://localhost:${PORT}/query`);
    console.log(`ğŸ¥ Health check: http://localhost:${PORT}/health`);
    console.log(`ğŸ“¡ Forwarding to backend: ${GO_BACKEND_URL}`);
    console.log("=".repeat(50) + "\n");
  });
  
  // Handle uncaught errors
  process.on("uncaughtException", (error) => {
    console.error("âŒ Uncaught Exception:", error);
  });
  
  process.on("unhandledRejection", (reason, promise) => {
    console.error("âŒ Unhandled Rejection at:", promise, "reason:", reason);
  });
}

// Start the server when this file is executed directly
start().catch((error) => {
  console.error("Failed to start server:", error);
  process.exit(1);
});

export { start };